From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: IPECTER <ipectert@gmail.com>
Date: Thu, 23 Mar 2023 14:32:26 +0900
Subject: [PATCH] Implement ChunkSending

Original: someaddons/chunksending
Copyright (C) 2023 someaddons

diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index e2202389a2c4133a183cca59c4e909fc419379ab..ccb7ff8832d3673a46d0a285f09d57d12bc0203a 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -398,9 +398,11 @@ public class ChunkHolder {
     // Paper end - rewrite chunk system
 
     private void broadcast(List<ServerPlayer> players, Packet<?> packet) {
-        players.forEach((entityplayer) -> {
-            entityplayer.connection.send(packet);
-        });
+        // Plazma start
+        for (ServerPlayer player : players)
+            if (this.chunkMap.level.plazmaLevelConfiguration().chunkSending.enabled && !player.attachToPending(pos, packet))
+                player.connection.send(packet);
+        // Plazma end
     }
 
     // Paper - rewrite chunk system
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 0249eeb3937cf48cea13846a7e39b248947e21a4..f39b3f1b5b37d1939766952a985684279cb2bf2d 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -772,7 +772,35 @@ public class ServerPlayer extends Player {
             }
         }
         // Purpur end
+    // Plazma start - Implement ChunkSending
+        if (this.level().plazmaLevelConfiguration().chunkSending.enabled) {
+            if (chunksToSend.isEmpty()) return;
+
+            if (disconnected) {
+                chunksToSend.clear();
+                return;
+            }
+
+            final List<java.util.Map.Entry<ChunkPos, List<Packet<?>>>> packets = new java.util.ArrayList<>(chunksToSend.entrySet());
+            packets.sort(java.util.Comparator.comparingDouble(e -> e.getKey().getMiddleBlockPosition(getBlockY()).distSqr(blockPosition())));
+
+            for (int i = 0; i < packets.size() && i < this.level().plazmaLevelConfiguration().chunkSending.maxChunksPerTick + packets.size() / 100; i++) {
+                final java.util.Map.Entry<ChunkPos, List<Packet<?>>> entry = packets.get(i);
+                for (final Packet<?> packet : entry.getValue()) {
+                    connection.send(packet);
+                }
+                chunksToSend.remove(entry.getKey());
+            }
+        }
+    }
+
+    public boolean attachToPending(final ChunkPos pos, final Packet<?> packet) {
+        final List<Packet<?>> packetList = chunksToSend.get(pos);
+        if (packetList == null) return false;
+        packetList.add(packet);
+        return true;
     }
+    // Plazma end
 
     public void doTick() {
         try {
@@ -2437,7 +2465,14 @@ public class ServerPlayer extends Player {
         return true; // Paper
     }
 
+    // Plazma start - Implement ChunkSending
+    private final java.util.Map<ChunkPos, List<Packet<?>>> chunksToSend = java.util.Collections.synchronizedMap(new java.util.HashMap<>());
     public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket) {
+        if (this.level().plazmaLevelConfiguration().chunkSending.enabled) {
+            List<Packet<?>> packetList = chunksToSend.computeIfAbsent(chunkPos, k -> new java.util.ArrayList<>());
+            packetList.add(chunkDataPacket);
+        }
+    // Plazma end
         this.connection.send(chunkDataPacket);
         // Paper start
         if(io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0){
